package database;

import graphics.Renderer;
import helper.MainController;

import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;

import collision.CollisionDetection;
import paulscode.sound.SoundSystemConfig;
import paulscode.sound.SoundSystemJPCT;
import entities.Actor;
import entities.Vehicle;


/*
 * Central processing class
 * Keep references to everything in here and initialise it 
 * 
 * 
 * 
 */


public class EngineDatabase {

	//viewport
	graphics.View view;

	graphics.Renderer renderer;

	//all controllers
	helper.MainController controller;

	//main game loop
	main.EngineMainLoop mainLoop;

	//keylistener running independently
	input.PlayerKeyListener playerKeyListener;

	//mouselistener running independently
	input.MainMouseListener mainMouseListener;

	//sound engine
	SoundSystemJPCT soundSystem = new SoundSystemJPCT();

	//globally accessible fps
	int currentfps=0;

	//globally accessible last clicked position
	int[] lastMouseClickPosition=new int[2];
	//globally accessible last mouse position
	int[] lastMousePosition=new int[2];
	boolean mousePressedDown=false;

	//actor factory
	factories.ActorFactory actorFactory = new factories.ActorFactory(this);

	//engine status, 0==paused,1==running,-1==stopped
	private int engineStatus;

	//graphics storage (don't forget /resources/)
	graphics.GraphicsStorage gs = new graphics.GraphicsStorage();

	//hash map where every entry is an Actor and their corresponding key is the objectID generated by the grid
	//using this later on for seperating certain actors in their own sublists
	ConcurrentHashMap<Integer,Actor> actorList = new ConcurrentHashMap<Integer,Actor>();
	CopyOnWriteArrayList<Vehicle> vehicleList = new CopyOnWriteArrayList<Vehicle>();

	//(extra) list just for collision detection
	CopyOnWriteArrayList<collision.Collider> allColliders = new CopyOnWriteArrayList<collision.Collider>();

	//debug map for colliders
	ConcurrentHashMap<Integer,collision.Collider> allCollidersMap = new ConcurrentHashMap<Integer,collision.Collider>();

	//list of actors in marking box
	CopyOnWriteArrayList<Actor> markedActors = new CopyOnWriteArrayList<Actor>();

	//collision detection
	private CollisionDetection cd;



	public EngineDatabase() {
		//initialize controllers first
		controller = new MainController(this);

		//create viewport
		view = new graphics.View(1600,1000,
				this);

		//combine view and controller functionality
		controller.createUIController();
		view.getMainFrame().getControlPanel().addUIController(controller.getUIController());
		view.getPopup().addUIController(controller.getUIController());

		//renderer = new Renderer(this,view);

		//create mouselistener and add to main game panel to capture mouse positions
		mainMouseListener = new input.MainMouseListener(this);
		view.getMainPanel().addMouseListener(mainMouseListener);
		view.getMainPanel().addMouseMotionListener(mainMouseListener);

		//create keylistener and add to main game panel
		playerKeyListener = new input.PlayerKeyListener();
		view.getMainPanel().addKeyListener(playerKeyListener);

		//set sound resource folder
		SoundSystemConfig.setSoundFilesPackage("resources/sounds/");
		soundSystem.setMasterVolume(0.1f);


	}

	/////////////////////////
	/////	
	/////	A C T I O N S
	/////
	/////////////////////////


	public void start() {
		//Testing Grounds
		
		
		mainLoop = new main.EngineMainLoop(this);

		for(int i=1;i<view.getMainFrame().getControlPanel().getColliderCount();i++){
			entities.Actor a = new entities.Actor(randInt(10,1500), randInt(10,750), 10, "WEST", this);

			getCollisionDetection().getGrid().addObject(a);
			actorList.put(a.getGridID(),a);
		}

		collision.CircleCollider circle = new collision.CircleCollider(200,200,100);

		getCollisionDetection().getGrid().addObject(circle);
		allCollidersMap.put(circle.getGridID(), circle);

		playerKeyListener.setPlayer(circle);

		/*for(int i=1;i<view.getMainFrame().getControlPanel().getColliderCount();i++){
		collision.CircleCollider c = new collision.CircleCollider(randInt(500,1000),randInt(300,600),15);

		getCollisionDetection().getGrid().addObject(c);

		allCollidersMap.put(c.getGridID(),c);*/
		/*}
		int[] xpoints2=new int[]{500,700,900,700};int[] ypoints2=new int[]{100,0,100,200};
		int[] xpoints=new int[]{500,700,900,700};int[] ypoints=new int[]{600,400,600,800};
		collision.PolygonCollider p2 = new collision.PolygonCollider(xpoints2, ypoints2);
		collision.PolygonCollider p1 = new collision.PolygonCollider(xpoints,ypoints);
		getCollisionDetection().getGrid().addObject(p1);
		allCollidersMap.put(p1.getGridID(), p1);
		getCollisionDetection().getGrid().addObject(p2);
		allCollidersMap.put(p2.getGridID(), p2);


		int[] xpoints=new int[]{100,250,300,250,100};int[] ypoints=new int[]{100,100,125,150,150};
		collision.PolygonCollider p1 = new collision.PolygonCollider(xpoints,ypoints);
		getCollisionDetection().getGrid().addObject(p1);
		allCollidersMap.put(p1.getGridID(), p1);*/
	}
	public void pauseMainLoop(){
		setEngineStatus(0);
	}
	public void resume(){
		setEngineStatus(1);
	}
	public void exit(){
		getAudio().cleanup();

		try{
			ExecutorService collisionPool = mainLoop.getCd().getExServ();


			collisionPool.shutdown();// Disable new tasks from being submitted

			try {
				// Wait a while for existing tasks to terminate
				if (!collisionPool.awaitTermination(5, TimeUnit.SECONDS)) {
					// Cancel currently executing tasks
					collisionPool.shutdownNow();
					// Wait a while for tasks to respond to being cancelled
					if (!collisionPool.awaitTermination(10, TimeUnit.SECONDS))
						System.err.println("Pool did not terminate");
				}
			} catch (final InterruptedException ie) {
				// (Re-)Cancel if current thread also interrupted
				collisionPool.shutdownNow();
				// Preserve interrupt status
				Thread.currentThread().interrupt();
			}
		}catch(NullPointerException e){
			System.out.println("No game has been created prior to exiting...");
		}
	}

	/////////////////////////
	/////	
	/////	E N T I T I E S
	/////
	/////////////////////////

	public ConcurrentHashMap<Integer,Actor> getActorList() {
		return actorList;
	}
	public void addActor(Actor a) {
		getActorList().put(a.getGridID(), a);
	}

	public CopyOnWriteArrayList<Vehicle> getVehicleList() {
		return vehicleList;
	}

	public CopyOnWriteArrayList<Actor> getMarkedActors(){
		return markedActors;
	}

	public CopyOnWriteArrayList<collision.Collider> getColliders() {
		return allColliders;
	}

	public ConcurrentHashMap<Integer, collision.Collider> getAllCollidersMap() {
		return allCollidersMap;
	}
	/////////////////////////
	/////	
	/////	M O U S E	A N D	K E Y B O A R D
	/////
	/////////////////////////

	//Basically just retrieving what the mouselistener puts out and catch it in this class
	public int[] getLastMousePosition() {
		return lastMousePosition;
	}
	public int[] getLastMouseClickPosition() {
		return lastMouseClickPosition;
	}
	public void setLastMouseClickPosition(MouseEvent e) {
		this.lastMouseClickPosition[0]=e.getX();this.lastMouseClickPosition[1]=e.getY();
	}
	public void setLastMousePosition(MouseEvent e) {
		this.lastMousePosition[0]=e.getX();this.lastMousePosition[1]=e.getY();
	}

	public boolean isMousePressedDown() {
		return mousePressedDown;
	}
	public void setMousePressedDown(boolean mousePressedDown) {
		this.mousePressedDown = mousePressedDown;
	}

	public input.PlayerKeyListener getPlayerKeyListener() {
		return playerKeyListener;
	}




	/////////////////////////
	/////	
	/////	O T H E R	G E T T E R S
	/////
	/////////////////////////


	public int getEngineStatus() {
		return engineStatus;
	}

	public int getCurrentfps() {
		return currentfps;
	}

	public factories.ActorFactory getActorFactory() {
		return actorFactory;
	}

	public graphics.GraphicsStorage getGs() {
		return gs;
	}

	public SoundSystemJPCT getAudio() {
		return soundSystem;
	}

	public graphics.View getView() {
		return this.view;
	}

	public MainController getController() {
		return controller;
	}

	public Renderer getRenderer() {
		return renderer;
	}

	public CollisionDetection getCollisionDetection() {
		return cd;
	}

	/////////////////////////
	/////	
	/////	H E L P E R		M E T H O D S
	/////
	/////////////////////////

	public void setCurrentfps(int currentfps) {
		this.currentfps = currentfps;
	}

	public void setCollisionDetection(CollisionDetection ncd) {
		this.cd=ncd;
	}

	public static int randInt(final int min, final int max) {
		final Random rand = new Random();
		final int randomNum = rand.nextInt((max - min) + 1) + min;
		return randomNum;
	}

	public void setEngineStatus(int es){
		this.engineStatus=es;
	}





}
